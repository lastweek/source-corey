#include <machine/pmap.h>
#include <machine/types.h>
#include <machine/boot.h>
#include <dev/nvram.h>
#include <dev/kclock.h>
#include <dev/acpi.h>
#include <kern/lib.h>
#include <kern/arch.h>
#include <kern/pageinfo.h>
#include <inc/error.h>
#include <inc/queue.h>

enum { pinit_debug = 0 };

static char *boot_freemem;	// Pointer to next byte of free mem
static char *boot_endmem;	// Pointer to first unusable byte
static uint64_t membytes;       // Maximum usuable bytes of the physical AS

static struct e820entry e820_map[E820MAX];
static uint8_t e820_nents;

// Keep track of various page metadata
page_info_t *page_infos;
uint64_t largest_ram_start;

static int
nvram_read(int r)
{
    return mc146818_read (r) | (mc146818_read (r + 1) << 8);
}

static void
e820_detect_memory(struct e820entry *desc, uint8_t n)
{
    extern char end[];
    uint64_t largest_ram_size = 0;
    membytes = 0;
    for (uint8_t i = 0; i < n; i++) {
        if (desc[i].type != E820_RAM)
            continue;
        
        membytes += desc[i].size;
        uint64_t s = ROUNDUP(desc[i].addr, PGSIZE);
        uint64_t e = ROUNDDOWN(desc[i].addr + desc[i].size, PGSIZE);

	// boot_alloc can only use memory from the contiguous physical
	// range that holds the kernel symbols.  'end' is a symbol 
	// generated by the linker, which  points to the end of the
	// kernel's bss segment - i.e. the first virtual address that the 
	// linker did _not_ assign to any kernel code or variables.
        if (s < RELOC(end) && RELOC(end) < e) {
	    boot_freemem = (char *)(RELOC(end) + PHYSBASE);
	    boot_endmem = (char *)(e + PHYSBASE);
	}
        
        // global_npages counts from 0 to the last RAM page.
        // The count may include unusable pages!
        if (e / PGSIZE > global_npages)
            global_npages = (e / PGSIZE);
        if (largest_ram_size < desc[i].size) {
            largest_ram_size = desc[i].size;
            largest_ram_start = desc[i].addr;
        }
    }
}

//
// Allocate n bytes of physical memory aligned on an 
// align-byte boundary.  Align must be a power of two.
// Return kernel virtual address.  Returned memory is uninitialized.
//
// It is neceassry that boot_alloc only return memory from the first
// 4 GB of the physical address space.  boot_alloc may be used to allocate 
// memory used before Long-Mode is enabled (like AP pgmaps).
//
// If we're out of memory, boot_alloc should panic.
// It's too early to run out of memory.
// This function may ONLY be used during initialization,
// before the page_free_list has been set up.
// 
static void *
boot_alloc(uint32_t n, uint32_t align)
{
    boot_freemem = (char *) ROUNDUP (boot_freemem, align);
    if (boot_freemem + n < boot_freemem || boot_freemem + n > boot_endmem)
	panic ("out of memory during i386_vm_init");
    void *v = boot_freemem;
    boot_freemem += n;
    return v;
}

static void __attribute__((unused))
print_memory_map(struct e820entry *desc, uint8_t n)
{
    for (int i = 0; i < n; i++) {
        cprintf(" BIOS-e820: %016lx - %016lx ", 
                desc[i].addr,
                desc[i].addr + desc[i].size);
        switch (desc[i].type) {
        case E820_RAM:
	    cprintf("(usable)\n");
            break;
        case E820_RESERVED:
            cprintf("(reserved)\n");
            break;
        case E820_ACPI:
            cprintf("(ACPI data)\n");
            break;
        case E820_NVS:
            cprintf("(ACPI NVS)\n");
            break;
        default:
            cprintf("type %u\n", desc[i].type);
            break;
        }
    }
}

static char
page_inuse(uint64_t ppn)
{
    extern char ereplicate[], sreplicate[];
    uint64_t rep_size = ROUNDUP((uintptr_t)ereplicate, PGSIZE) - 
	ROUNDDOWN((uintptr_t)sreplicate, PGSIZE);
    
    if (ppn == 0)
	return 1;
    else if (ppn == (APBOOTSTRAP / PGSIZE))
	return 1;
    else if (ppn >= IOPHYSMEM / PGSIZE && 
	     ppn < EXTPHYSMEM / PGSIZE)
	return 1;
    else if (ppn >= (EXTPHYSMEM / PGSIZE) &&
	     ppn < ((uint64_t)boot_freemem - PHYSBASE) / PGSIZE)
	return 1;
    else {
	for (int k = 0; k < nmemnode; k++) {
	    if (rep_size > memnode[k].length)
		continue;
	    else if (ppn >= (memnode[k].baseaddr / PGSIZE) && 
		     ppn < ((memnode[k].baseaddr + rep_size) / PGSIZE)) 
	    {
		return 1;
	    }
	}
    }
    return 0;
}

static void
e820_page_init(struct e820entry *desc, uint8_t n)
{
    for (uint8_t i = 0; i < n; i++) {
        if (desc[i].type != E820_RAM)
            continue;
        
        uint64_t startpg = ROUNDUP(desc[i].addr, PGSIZE) / PGSIZE;
        uint64_t endpg = ROUNDDOWN(desc[i].addr + desc[i].size, PGSIZE) / PGSIZE;

        for (uint64_t j = startpg; j < endpg; j++)
	    if (!page_inuse(j))
		page_free(pa2kva(j << PGSHIFT));
    }

    cprintf("Physical memory: %ldMB of %ldMB available\n", 
	    (jos_atomic_read(&page_stats.pages_avail) << PGSHIFT) / (1024 * 1024),
	    membytes / (1024 * 1024));
}

void
mem_init(uint64_t lower_kb, uint64_t upper_kb, struct e820entry *map, uint8_t n)
{
    if (!map || !n) {
	// Fake an e820 map
	if (!lower_kb)
	    lower_kb = nvram_read(NVRAM_BASELO);
	if (!upper_kb)
	    upper_kb = nvram_read (NVRAM_EXTLO);
	
	e820_map[0].addr = 0;
	e820_map[0].size = ROUNDDOWN(lower_kb * 1024, PGSIZE);
	e820_map[0].type = E820_RAM;
	assert(e820_map[0].size <= IOPHYSMEM);
	
	e820_map[1].addr = EXTPHYSMEM;
	e820_map[1].size = ROUNDDOWN(upper_kb * 1024, PGSIZE);
	e820_map[1].type = E820_RAM;
	
	e820_nents = 2;
    } else {
	memcpy(e820_map, map, n * sizeof(*map));
	e820_nents = n;
    }
    
    e820_detect_memory(e820_map, e820_nents);
}

void 
page_init(void)
{
    page_alloc_init();

    // Align boot_freemem to page boundary.
    boot_alloc(0, PGSIZE);
    
    // Allocate space for page status info.
    uint64_t sz = global_npages * sizeof(*page_infos);
    page_infos = boot_alloc(sz, PGSIZE);
    memset(page_infos, 0, sz);

    // Align to another page boundary.
    boot_alloc(0, PGSIZE);

    e820_page_init(e820_map, e820_nents);
    jos_atomic_set64(&page_stats.pages_used, 0);

    // Register hardware pages for VM use
    for (uint64_t i = IOPHYSMEM; i < BIOSPHYSMEM; i += PGSIZE)
	page_register_hw(pa2kva(i));
}
